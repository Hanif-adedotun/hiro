import { NextRequest, NextResponse } from 'next/server'
import { getSession } from '@/lib/auth/session'
import { prisma } from '@/lib/db/client'
import { updateTestJob } from '@/lib/db/queries'
import { createAppClient, createUserClient } from '@/lib/github/client'

export async function POST(
  request: NextRequest,
  { params }: { params: { jobId: string } }
) {
  try {
    const session = await getSession()
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const job = await prisma.testJob.findUnique({
      where: { id: params.jobId },
      include: {
        repository: {
          include: {
            user: true,
            installation: true,
          },
        },
        testResults: true,
      },
    })

    if (!job) {
      return NextResponse.json({ job: null, error: 'Job not found' }, { status: 404 })
    }

    if (job.repository.userId !== session.user.id) {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    if (job.status !== 'completed') {
      return NextResponse.json(
        { error: 'Only completed jobs can be accepted. Wait for the job to finish.' },
        { status: 400 }
      )
    }

    if (job.suggestedPrId != null && job.suggestedPrUrl) {
      return NextResponse.json(
        { error: 'This job was already accepted.', prUrl: job.suggestedPrUrl },
        { status: 400 }
      )
    }

    if (job.testResults.length === 0) {
      return NextResponse.json(
        { error: 'No test results to create a PR from.' },
        { status: 400 }
      )
    }

    const repo = job.repository
    let github
    if (repo.installationId && repo.installation) {
      const appId = process.env.GITHUB_APP_ID!
      const privateKey = process.env.GITHUB_APP_PRIVATE_KEY!
      github = createAppClient(appId, privateKey, repo.installation.installationId)
    } else if (repo.user?.accessToken) {
      github = createUserClient(repo.user.accessToken)
    } else {
      return NextResponse.json(
        { error: 'No GitHub authentication available for this repository.' },
        { status: 400 }
      )
    }

    const baseBranch =
      (job.metadata && typeof job.metadata === 'object' && job.metadata.branch) ||
      repo.defaultBranch
    const shortId = job.id.slice(-7)
    const branchName = `hiro-tests/${baseBranch}-${shortId}`

    await github.createBranch(repo.owner, repo.name, branchName, baseBranch)

    for (const tr of job.testResults) {
      await github.commitFile(
        repo.owner,
        repo.name,
        branchName,
        tr.testFilePath,
        tr.testCode,
        `Add tests for ${tr.filePath}`
      )
    }

    const pr = await github.createPullRequest(
      repo.owner,
      repo.name,
      `Hiro: AI-generated tests (${job.testResults.length} file(s))`,
      branchName,
      baseBranch,
      `Generated by Hiro for ${job.targetFiles.length} source file(s).`
    )

    await updateTestJob(job.id, {
      status: 'pr_created',
      suggestedPrId: String(pr.number),
      suggestedPrUrl: pr.html_url ?? undefined,
    })

    return NextResponse.json({
      prUrl: pr.html_url,
      prNumber: pr.number,
      branch: branchName,
    })
  } catch (error) {
    console.error('Error accepting job:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create PR' },
      { status: 500 }
    )
  }
}
